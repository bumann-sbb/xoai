/*
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree and available online at
 *
 * http://www.dspace.org/license/
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, vhudson-jaxb-ri-2.2-147
// See <a href="client://java.sun.com/xml/jaxb">client://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.01.13 at 08:24:23 PM WET
//

package io.gdcc.xoai.model.oaipmh;

import io.gdcc.xoai.model.oaipmh.verbs.Verb.Argument;
import io.gdcc.xoai.model.oaipmh.verbs.Verb.Type;
import io.gdcc.xoai.xml.XmlWritable;
import io.gdcc.xoai.xml.XmlWriter;
import io.gdcc.xoai.xmlio.exceptions.XmlWriteException;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.xml.stream.XMLStreamException;

/** The modeling class representing the responses request repetition <OAI-PMH><request> */
public class Request implements XmlWritable {

    private final String baseUrl;
    // From + Until get saved here as raw values, too, aiding in request validation
    private final Map<Argument, String> arguments = new EnumMap<>(Argument.class);
    private Type type;
    private Instant from;
    private Instant until;

    /**
     * Create a new request in its most basic form with just the base URL. According to spec, when
     * responding with an error, the < request > part must be present and contain this base URL,
     * even if the verb is not given/illegal.
     *
     * @param baseUrl The endpoint URL
     */
    public Request(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    public String getBaseUrl() {
        return baseUrl;
    }

    public Optional<Type> getType() {
        return Optional.ofNullable(type);
    }

    public Optional<String> getVerb() {
        return Optional.ofNullable(arguments.get(Argument.Verb));
    }

    public Request withVerb(Type type) {
        Objects.requireNonNull(type);
        this.type = type;
        this.arguments.put(Argument.Verb, type.displayName());
        return this;
    }

    public Optional<String> getIdentifier() {
        return Optional.ofNullable(arguments.get(Argument.Identifier));
    }

    public Request withIdentifier(String value) {
        this.arguments.put(Argument.Identifier, value);
        return this;
    }

    public Optional<String> getMetadataPrefix() {
        return Optional.ofNullable(arguments.get(Argument.MetadataPrefix));
    }

    public Request withMetadataPrefix(String value) {
        this.arguments.put(Argument.MetadataPrefix, value);
        return this;
    }

    public Optional<Instant> getFrom() {
        return Optional.ofNullable(from);
    }

    public Request withFrom(Instant value) {
        this.from = value;
        return this;
    }

    /** Only used for validation during request building */
    public void saveRawFrom(String value) {
        this.arguments.put(Argument.From, value);
    }

    /** Only used for validation during request building */
    public String getRawFrom() {
        return this.arguments.get(Argument.From);
    }

    public Optional<Instant> getUntil() {
        return Optional.ofNullable(until);
    }

    public Request withUntil(Instant value) {
        this.until = value;
        return this;
    }

    /** Only used for validation during request building */
    public void saveRawUntil(String value) {
        this.arguments.put(Argument.Until, value);
    }

    /** Only used for validation during request building */
    public String getRawUntil() {
        return this.arguments.get(Argument.Until);
    }

    public Optional<String> getSet() {
        return Optional.ofNullable(this.arguments.get(Argument.Set));
    }

    public Request withSet(String value) {
        this.arguments.put(Argument.Set, value);
        return this;
    }

    /**
     * A request may contain (as an exclusive argument) an encoded {@link ResumptionToken.Value}. It
     * must be decoded with a {@link io.gdcc.xoai.services.api.ResumptionTokenFormat} before being
     * useful.
     */
    public Optional<String> getResumptionToken() {
        return Optional.ofNullable(this.arguments.get(Argument.ResumptionToken));
    }

    /** Set a string with an encoded {@link ResumptionToken.Value}. */
    public Request withResumptionToken(String value) {
        this.arguments.put(Argument.ResumptionToken, value);
        return this;
    }

    @Override
    public void write(XmlWriter writer) throws XmlWriteException {
        try {
            // These might be not present, depending on the verb and the validity of the verb.
            // Validation of the request happens before writing out the response, so simply write
            // things
            // present.
            // (Unwrapping the optional happens in the writer)
            writer.writeAttribute(Argument.Verb, getVerb());
            writer.writeAttribute(Argument.Identifier, getIdentifier());
            writer.writeAttribute(Argument.MetadataPrefix, getMetadataPrefix());
            writer.writeAttribute(Argument.From, getFrom());
            writer.writeAttribute(Argument.Until, getUntil());
            writer.writeAttribute(Argument.Set, getSet());
            writer.writeAttribute(Argument.ResumptionToken, getResumptionToken());

            // Spec says within the <request> must be the OAI-PMH data provider endpoints base URL
            // no
            // matter what.
            writer.writeCharacters(getBaseUrl());
        } catch (XMLStreamException e) {
            throw new XmlWriteException(e);
        }
    }
}
