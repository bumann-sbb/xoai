/*
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree and available online at
 *
 * http://www.dspace.org/license/
 */

package io.gdcc.xoai.model.oaipmh;

import io.gdcc.xoai.xmlio.exceptions.XmlWriteException;
import io.gdcc.xoai.xml.XmlWritable;
import io.gdcc.xoai.xml.XmlWriter;

import javax.xml.stream.XMLStreamException;
import java.time.Instant;
import java.util.Objects;

public final class ResumptionToken implements XmlWritable {

    private final Value value;
    private Instant expirationDate;
    private Long completeListSize;
    private Long cursor;

    public ResumptionToken (Value value) {
        this.value = value;
    }
    public ResumptionToken () {
        this.value = new Value();
    }

    public Value getValue() {
        return value;
    }

    public Instant getExpirationDate() {
        return expirationDate;
    }

    public ResumptionToken withExpirationDate(Instant value) {
        this.expirationDate = value;
        return this;
    }

    public Long getCompleteListSize() {
        return completeListSize;
    }

    public ResumptionToken withCompleteListSize(long value) {
        this.completeListSize = value;
        return this;
    }

    public Long getCursor() {
        return cursor;
    }

    public ResumptionToken withCursor(long value) {
        this.cursor = value;
        return this;
    }

    @Override
    public void write(XmlWriter writer) throws XmlWriteException {
        try {
            if (this.expirationDate != null)
                writer.writeAttribute("expirationDate", this.expirationDate, Granularity.Second);
            if (this.completeListSize != null)
                writer.writeAttribute("completeListSize", "" + this.completeListSize);
            if (this.cursor != null)
                writer.writeAttribute("cursor", "" + this.cursor);
            if (this.value != null)
                writer.write(this.value);
        } catch (XMLStreamException e) {
            throw new XmlWriteException(e);
        }
    }
    
    /**
     * Create a new resumption token with a builder pattern (which makes {@link Value} immutable).
     */
    public static final class ValueBuilder {
        private Long offset;
        private String set;
        private Instant from;
        private Instant until;
        private String metadataPrefix;
    
        public ValueBuilder withOffset(long integer) {
            this.offset = integer;
            return this;
        }
    
        public ValueBuilder withSetSpec(String setSpec) {
            this.set = setSpec;
            return this;
        }
    
        public ValueBuilder withFrom(Instant from) {
            this.from = from;
            return this;
        }
    
        public ValueBuilder withUntil(Instant until) {
            this.until = until;
            return this;
        }
    
        public ValueBuilder withMetadataPrefix(String metadataPrefix) {
            this.metadataPrefix = metadataPrefix;
            return this;
        }
        
        public Value build() {
            return new Value(offset, set, from, until, metadataPrefix);
        }
    
        /**
         * Create an all new resumption token from an (initial) request
         * @param request The request sent by the client
         * @return An immutable resumption token value
         */
        public static ResumptionToken.Value build(Request request) {
            final ResumptionToken.ValueBuilder tokenBuilder = new ResumptionToken.ValueBuilder();
        
            tokenBuilder.withOffset(0);
            request.getMetadataPrefix().ifPresent(tokenBuilder::withMetadataPrefix);
            request.getFrom().ifPresent(tokenBuilder::withFrom);
            request.getUntil().ifPresent(tokenBuilder::withUntil);
            request.getSet().ifPresent(tokenBuilder::withSetSpec);
        
            return tokenBuilder.build();
        }
    }
    
    /**
     * Representing the content of a resumption token generated by us, formatted as token via a
     * {@link io.gdcc.xoai.services.api.ResumptionTokenFormat}, sent to the client and sent to us
     * when continuing the last request for data.
     *
     * Immutable object, can only be build via {@link ValueBuilder} or be used to create another immutable
     * object representing the next chunk sent to the client via {@link #next(long)}.
     */
    public static final class Value {
        private final Long offset;
        private final String set;
        private final Instant from;
        private final Instant until;
        private final String metadataPrefix;

        Value() {
            this.offset = null;
            this.set = this.metadataPrefix = null;
            this.from = this.until = null;
        }
        
        Value(Long offset, String set, Instant from, Instant until, String metadataPrefix) {
            this.offset = offset;
            this.set = set;
            this.from = from;
            this.until = until;
            this.metadataPrefix = metadataPrefix;
        }
        
        public boolean isEmpty () {
            return Objects.isNull(offset) &&
                Objects.isNull(set) &&
                Objects.isNull(from) &&
                Objects.isNull(until) &&
                Objects.isNull(metadataPrefix);
        }
    
        /**
         * Create a new resumption token value from this token, given the count of items returned with
         * this answer to a client. The client is supposed to send this new token on the next request.
         *
         * @param sum The amount of item returned in this chunk
         * @return
         */
        public Value next(long sum) {
            return new Value(
                (this.offset == null ? 0 : this.offset) + sum,
                this.set, this.from, this.until, this.metadataPrefix);
        }

        public long getOffset() {
            return offset == null ? 0 : offset;
        }

        public String getSetSpec() {
            return set;
        }

        public Instant getFrom() {
            return from;
        }

        public Instant getUntil() {
            return until;
        }

        public String getMetadataPrefix() {
            return metadataPrefix;
        }


        public boolean hasOffset() {
            return offset != null;
        }

        public boolean hasSetSpec() {
            return set != null;
        }

        public boolean hasFrom() {
            return from != null;
        }

        public boolean hasUntil() {
            return until != null;
        }

        public boolean hasMetadataPrefix() {
            return metadataPrefix != null;
        }
    
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Value)) return false;
            Value value = (Value) o;
            return Objects.equals(getOffset(), value.getOffset()) &&
                Objects.equals(getSetSpec(), value.getSetSpec()) &&
                Objects.equals(getFrom(), value.getFrom()) &&
                Objects.equals(getUntil(), value.getUntil()) &&
                Objects.equals(getMetadataPrefix(), value.getMetadataPrefix());
        }
    
        @Override
        public int hashCode() {
            return Objects.hash(getOffset(), getSetSpec(), getFrom(), getUntil(), getMetadataPrefix());
        }
    
        @Override
        public String toString() {
            return "Value{" +
                "offset=" + offset +
                ", set='" + set + '\'' +
                ", from=" + from +
                ", until=" + until +
                ", metadataPrefix='" + metadataPrefix + '\'' +
                '}';
        }
    }
}
